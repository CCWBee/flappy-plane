<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#1e3a5f">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>TU-95</title>
  <link rel="manifest" href="../manifest.json">
  <link rel="apple-touch-icon" href="../icons/icon-192.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #1e3a5f;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    canvas { display: block; width: 100%; height: 100%; }
    #rotate-msg {
      display: none;
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #1a1a2e;
      color: #fff;
      font-family: Arial, sans-serif;
      justify-content: center; align-items: center;
      flex-direction: column;
      z-index: 999;
      text-align: center;
      padding: 20px;
    }
    #rotate-msg .icon { font-size: 60px; margin-bottom: 16px; }
    #rotate-msg p { font-size: 18px; opacity: 0.8; }
    @media (orientation: portrait) and (max-width: 600px) {
      #rotate-msg { display: flex; }
    }
  </style>
</head>
<body>
  <div id="rotate-msg">
    <div class="icon">&#128260;</div>
    <p>Rotate your device to landscape</p>
  </div>
  <canvas id="game"></canvas>
  <script>
  'use strict';

  // ===== CANVAS SETUP =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  window.addEventListener('resize', resize);

  function W() { return window.innerWidth; }
  function H() { return window.innerHeight; }

  // ===== CONSTANTS =====
  const GRAVITY = 9.8;
  const MAX_THRUST = 48;
  const LIFT_COEFF = 0.0055;
  const DRAG_COEFF = 0.0018;
  const PITCH_SPEED = 1.8;
  const STALL_SPEED = 28;
  const FLAP_LIFT = [1.0, 1.6, 2.2];
  const FLAP_DRAG = [1.0, 1.3, 1.8];
  const GEAR_DRAG = 0.0007;
  const FUEL_BURN = 0.08; // %/sec at full throttle
  const PPM = 4; // pixels per meter
  const FLAP_NAMES = ['UP', 'T/O', 'LDG'];

  // ===== GAME STATES =====
  const ST = { MENU: 0, BRIEFING: 1, PLAYING: 2, CRASHED: 3, DEBRIEF: 4, PAUSED: 5 };
  let state = ST.MENU;
  let missionIdx = 0;
  let gameTime = 0;
  let frameCount = 0;
  let lastTime = 0;

  // Progress
  let progress = JSON.parse(localStorage.getItem('tu95_progress') || '{"unlocked":1,"scores":{}}');
  function saveProgress() { localStorage.setItem('tu95_progress', JSON.stringify(progress)); }

  // ===== PLANE STATE =====
  let plane = {};
  function resetPlane(mission) {
    const rx = mission.startRunway.x + 50;
    plane = {
      x: rx, y: mission.startRunway.y + 0.1,
      vx: 0, vy: 0,
      pitch: 0, pitchInput: 0,
      throttle: 0, fuel: mission.startFuel || 100,
      flaps: 0, gear: true,
      onGround: true, speed: 0,
      crashed: false, landedAt: null,
    };
  }

  // Camera
  let cam = { x: 0, y: 0 };

  // Bombs
  let bombs = [];
  let explosions = [];

  // Barrel rolls
  let rollAccum = 0, lastPitch = 0, rollStart = 0, barrelRolls = 0;

  // Objectives
  let objectives = [];
  let currentObj = 0;
  let objCompleted = 0;

  // Tutorial
  let tutorialMsg = '';
  let tutorialTimer = 0;
  let tutorialFired = {};

  // Floating text
  let floatingTexts = [];

  // Weather
  let rainDrops = [];
  let gustForce = 0, gustTimer = 0;
  let lightningTimer = 0, lightningFlash = false;
  let turbulenceTimer = 0;

  // HUD warning flash
  let warningTimer = 0;

  // Debrief data
  let debriefData = null;

  // ===== MISSION DATA =====
  const MISSIONS = [
    // Mission 1: First Flight (Tutorial)
    {
      id: 1, name: 'First Flight',
      briefing: 'Welcome to the TU-95, comrade! I am Pavel, your instructor. Today you learn to fly. Follow my instructions and you will do fine.',
      terrain: [
        {x:0,y:0},{x:400,y:0},{x:600,y:5},{x:900,y:15},{x:1200,y:10},
        {x:1500,y:0},{x:2000,y:8},{x:2500,y:20},{x:3000,y:15},
        {x:3500,y:5},{x:4000,y:0},{x:4500,y:0},{x:5000,y:8},
        {x:5500,y:15},{x:6000,y:5},{x:6500,y:0},{x:7200,y:0},
        {x:7500,y:0},{x:8000,y:0}
      ],
      startRunway: {x: 50, endX: 350, y: 0},
      endRunway: {x: 7200, endX: 7500, y: 0},
      worldLength: 8000,
      startFuel: 100,
      objectives: [
        {type:'altitude', value: 150, text:'Climb to 500 ft'},
        {type:'waypoint', x:2500, y:200, text:'Fly to waypoint A'},
        {type:'waypoint', x:5000, y:150, text:'Fly to waypoint B'},
        {type:'land', runway:'end', text:'Land at destination'},
      ],
      tutorial: true,
      weather: 'clear',
      par: {time:200, fuel:35},
      farMountains: [{x:0,h:120},{x:400,h:180},{x:800,h:100},{x:1200,h:200},{x:1600,h:140},{x:2000,h:190},{x:2400,h:110},{x:2800,h:170},{x:3200,h:130},{x:3600,h:160},{x:4000,h:140},{x:4400,h:190},{x:4800,h:120},{x:5200,h:170},{x:5600,h:150},{x:6000,h:180},{x:6400,h:110},{x:6800,h:160},{x:7200,h:140},{x:7600,h:170},{x:8000,h:130}],
      objects: [],
    },
    // Mission 2: Solo Circuit
    {
      id: 2, name: 'Solo Circuit',
      briefing: 'Time to fly on your own, comrade. Take off, follow the waypoints, and land at the destination. No hand-holding this time!',
      terrain: [
        {x:0,y:0},{x:350,y:0},{x:600,y:10},{x:1000,y:30},{x:1400,y:50},
        {x:1800,y:35},{x:2200,y:15},{x:2800,y:40},{x:3200,y:60},
        {x:3600,y:45},{x:4000,y:20},{x:4500,y:10},{x:5000,y:0},
        {x:5500,y:5},{x:6000,y:15},{x:6500,y:5},{x:7000,y:0},
        {x:7500,y:0},{x:8500,y:0}
      ],
      startRunway: {x:50, endX:300, y:0},
      endRunway: {x:7500, endX:7800, y:0},
      worldLength: 8500,
      startFuel: 100,
      objectives: [
        {type:'altitude', value:200, text:'Climb to 650 ft'},
        {type:'waypoint', x:2000, y:250, text:'Fly to waypoint A'},
        {type:'waypoint', x:4000, y:200, text:'Fly to waypoint B'},
        {type:'waypoint', x:6000, y:180, text:'Fly to waypoint C'},
        {type:'land', runway:'end', text:'Land at destination'},
      ],
      tutorial: false,
      weather: 'clear',
      par: {time:200, fuel:30},
      farMountains: [{x:0,h:150},{x:500,h:200},{x:1000,h:160},{x:1500,h:220},{x:2000,h:180},{x:2500,h:210},{x:3000,h:140},{x:3500,h:200},{x:4000,h:170},{x:4500,h:190},{x:5000,h:150},{x:5500,h:210},{x:6000,h:170},{x:6500,h:200},{x:7000,h:140},{x:7500,h:180},{x:8000,h:160},{x:8500,h:190}],
      objects: [{type:'city', x:2500, width:300}],
    },
    // Mission 3: Mountain Pass
    {
      id: 3, name: 'Mountain Pass',
      briefing: 'The route ahead goes through a mountain range. Fly high and watch for wind gusts. Stay alert!',
      terrain: [
        {x:0,y:0},{x:350,y:0},{x:700,y:20},{x:1000,y:80},{x:1300,y:200},
        {x:1600,y:350},{x:1800,y:280},{x:2000,y:150},{x:2300,y:300},
        {x:2600,y:400},{x:2900,y:320},{x:3200,y:200},{x:3500,y:100},
        {x:3800,y:50},{x:4200,y:30},{x:4600,y:10},{x:5000,y:0},
        {x:5500,y:0},{x:6000,y:0}
      ],
      startRunway: {x:50, endX:300, y:0},
      endRunway: {x:5500, endX:5800, y:0},
      worldLength: 6000,
      startFuel: 100,
      objectives: [
        {type:'altitude', value:400, text:'Climb above the peaks (1300 ft)'},
        {type:'waypoint', x:1600, y:450, text:'Clear the first peak'},
        {type:'waypoint', x:2600, y:500, text:'Clear the highest peak'},
        {type:'waypoint', x:4000, y:200, text:'Descend past the range'},
        {type:'land', runway:'end', text:'Land at mountain base'},
      ],
      tutorial: false,
      weather: 'windy',
      par: {time:180, fuel:30},
      farMountains: [{x:0,h:200},{x:400,h:300},{x:800,h:250},{x:1200,h:400},{x:1600,h:350},{x:2000,h:450},{x:2400,h:380},{x:2800,h:300},{x:3200,h:250},{x:3600,h:200},{x:4000,h:150},{x:4400,h:180},{x:4800,h:130},{x:5200,h:160},{x:5600,h:140},{x:6000,h:170}],
      objects: [],
    },
    // Mission 4: Bombing Run
    {
      id: 4, name: 'Bombing Run',
      briefing: 'Three targets have been identified. Fly over each one and drop your payload. Press B or the BOMB button when you are above a target. Then land safely.',
      terrain: [
        {x:0,y:0},{x:400,y:0},{x:800,y:10},{x:1200,y:5},{x:1600,y:0},
        {x:2000,y:8},{x:2400,y:15},{x:2800,y:10},{x:3200,y:5},
        {x:3600,y:0},{x:4000,y:10},{x:4400,y:20},{x:4800,y:15},
        {x:5200,y:5},{x:5600,y:0},{x:6000,y:0},{x:6500,y:0},{x:7000,y:0}
      ],
      startRunway: {x:50, endX:350, y:0},
      endRunway: {x:6500, endX:6800, y:0},
      worldLength: 7000,
      startFuel: 100,
      objectives: [
        {type:'altitude', value:100, text:'Climb to bombing altitude'},
        {type:'bomb', x:1800, y:0, radius:60, text:'Bomb target Alpha'},
        {type:'bomb', x:3400, y:0, radius:60, text:'Bomb target Bravo'},
        {type:'bomb', x:5000, y:0, radius:60, text:'Bomb target Charlie'},
        {type:'land', runway:'end', text:'Return to base'},
      ],
      tutorial: false,
      weather: 'clear',
      par: {time:200, fuel:30},
      farMountains: [{x:0,h:100},{x:500,h:140},{x:1000,h:120},{x:1500,h:160},{x:2000,h:130},{x:2500,h:150},{x:3000,h:110},{x:3500,h:140},{x:4000,h:120},{x:4500,h:150},{x:5000,h:130},{x:5500,h:140},{x:6000,h:110},{x:6500,h:130},{x:7000,h:120}],
      objects: [
        {type:'target', x:1800, y:0, radius:60},
        {type:'target', x:3400, y:0, radius:60},
        {type:'target', x:5000, y:0, radius:60},
      ],
    },
    // Mission 5: Storm Front
    {
      id: 5, name: 'Storm Front',
      briefing: 'A major storm system lies ahead. Expect heavy rain, poor visibility, and severe turbulence. Keep your nerve, comrade.',
      terrain: [
        {x:0,y:0},{x:400,y:0},{x:800,y:15},{x:1200,y:40},{x:1600,y:60},
        {x:2000,y:45},{x:2400,y:25},{x:2800,y:50},{x:3200,y:70},
        {x:3600,y:55},{x:4000,y:30},{x:4400,y:15},{x:4800,y:5},
        {x:5200,y:0},{x:5700,y:0},{x:6200,y:0}
      ],
      startRunway: {x:50, endX:350, y:0},
      endRunway: {x:5700, endX:6000, y:0},
      worldLength: 6200,
      startFuel: 100,
      objectives: [
        {type:'altitude', value:250, text:'Climb above 800 ft'},
        {type:'waypoint', x:1500, y:300, text:'Enter the storm'},
        {type:'waypoint', x:3000, y:280, text:'Navigate through storm'},
        {type:'waypoint', x:4500, y:200, text:'Exit the storm'},
        {type:'land', runway:'end', text:'Land through poor visibility'},
      ],
      tutorial: false,
      weather: 'storm',
      par: {time:190, fuel:30},
      farMountains: [{x:0,h:120},{x:500,h:180},{x:1000,h:150},{x:1500,h:200},{x:2000,h:170},{x:2500,h:210},{x:3000,h:160},{x:3500,h:190},{x:4000,h:140},{x:4500,h:170},{x:5000,h:130},{x:5500,h:160},{x:6000,h:140},{x:6200,h:150}],
      objects: [],
    },
    // Mission 6: Long Haul
    {
      id: 6, name: 'Long Haul',
      briefing: 'Your longest mission yet. Conserve fuel carefully â€” you will fly through day, dusk, and into night. Bomb two targets en route. Good luck, comrade.',
      terrain: [
        {x:0,y:0},{x:400,y:0},{x:800,y:10},{x:1500,y:30},{x:2200,y:50},
        {x:3000,y:20},{x:3800,y:0},{x:4500,y:15},{x:5200,y:40},
        {x:6000,y:80},{x:6800,y:100},{x:7500,y:70},{x:8200,y:30},
        {x:9000,y:10},{x:10000,y:0},{x:11000,y:5},{x:12000,y:20},
        {x:13000,y:10},{x:14000,y:0},{x:14500,y:0},{x:15000,y:0}
      ],
      startRunway: {x:50, endX:350, y:0},
      endRunway: {x:14500, endX:14800, y:0},
      worldLength: 15000,
      startFuel: 100,
      objectives: [
        {type:'altitude', value:200, text:'Climb to cruising altitude'},
        {type:'waypoint', x:3000, y:250, text:'Fly to checkpoint A'},
        {type:'bomb', x:5000, y:0, radius:70, text:'Bomb target Alpha'},
        {type:'waypoint', x:8000, y:300, text:'Fly to checkpoint B'},
        {type:'bomb', x:11000, y:0, radius:70, text:'Bomb target Bravo'},
        {type:'waypoint', x:13000, y:150, text:'Begin descent'},
        {type:'land', runway:'end', text:'Land at destination'},
      ],
      tutorial: false,
      weather: 'night',
      par: {time:400, fuel:15},
      farMountains: [],
      objects: [
        {type:'target', x:5000, y:0, radius:70},
        {type:'target', x:11000, y:0, radius:70},
        {type:'city', x:3500, width:400},
        {type:'city', x:9000, width:500},
        {type:'water', x:6500, endX:7500},
      ],
    },
  ];

  // ===== TERRAIN HELPERS =====
  function groundHeightAt(x, terrain) {
    if (x <= terrain[0].x) return terrain[0].y;
    if (x >= terrain[terrain.length-1].x) return terrain[terrain.length-1].y;
    for (let i = 0; i < terrain.length - 1; i++) {
      if (x >= terrain[i].x && x <= terrain[i+1].x) {
        const t = (x - terrain[i].x) / (terrain[i+1].x - terrain[i].x);
        return terrain[i].y + t * (terrain[i+1].y - terrain[i].y);
      }
    }
    return 0;
  }

  function isRunway(x, runway) {
    return x >= runway.x && x <= runway.endX;
  }

  // ===== WORLD TO SCREEN =====
  function w2s(wx, wy) {
    return {
      sx: (wx - cam.x) * PPM + W() / 2,
      sy: H() * 0.65 - (wy - cam.y) * PPM
    };
  }

  // ===== PHYSICS =====
  function updatePhysics(dt, mission) {
    if (dt > 0.05) dt = 0.05; // cap

    // Thrust
    const thrust = MAX_THRUST * plane.throttle;
    let ax = thrust * Math.cos(plane.pitch);
    let ay = thrust * Math.sin(plane.pitch);

    // Lift
    let lift = LIFT_COEFF * plane.speed * plane.speed * FLAP_LIFT[plane.flaps];
    if (plane.speed < STALL_SPEED) {
      const sf = plane.speed / STALL_SPEED;
      lift *= sf * sf;
    }
    const liftAngle = plane.pitch + Math.PI / 2;
    ay += lift * Math.sin(liftAngle);
    ax += lift * Math.cos(liftAngle);

    // Drag
    let dragC = DRAG_COEFF * FLAP_DRAG[plane.flaps];
    if (plane.gear) dragC += GEAR_DRAG;
    const drag = dragC * plane.speed * plane.speed;
    if (plane.speed > 0.5) {
      ax -= drag * (plane.vx / plane.speed);
      ay -= drag * (plane.vy / plane.speed);
    }

    // Gravity
    ay -= GRAVITY;

    // Wind gusts
    if (mission.weather === 'windy' || mission.weather === 'storm') {
      ay += gustForce;
    }

    // Turbulence (storm)
    if (mission.weather === 'storm' && !plane.onGround) {
      turbulenceTimer -= dt;
      if (turbulenceTimer <= 0) {
        turbulenceTimer = 0.5 + Math.random() * 1.5;
        plane.pitchInput += (Math.random() - 0.5) * 0.6;
      }
    }

    // Ground friction when on ground
    if (plane.onGround) {
      ay = 0;
      plane.vy = 0;
      // Rolling friction
      if (plane.speed > 0.5) {
        ax -= 2.0 * (plane.vx / plane.speed);
      }
      // Can't pitch below ground
      if (plane.pitch < 0) plane.pitch = 0;
    }

    // Apply
    plane.vx += ax * dt;
    plane.vy += ay * dt;
    plane.x += plane.vx * dt;
    plane.y += plane.vy * dt;
    plane.speed = Math.sqrt(plane.vx * plane.vx + plane.vy * plane.vy);

    // Pitch
    plane.pitch += plane.pitchInput * PITCH_SPEED * dt;
    plane.pitch = Math.max(-0.8, Math.min(0.8, plane.pitch));

    // Ground check
    const gh = groundHeightAt(plane.x, mission.terrain);
    if (plane.y <= gh) {
      const onStartRwy = isRunway(plane.x, mission.startRunway);
      const onEndRwy = isRunway(plane.x, mission.endRunway);
      if ((onStartRwy || onEndRwy) && plane.gear && plane.vy > -3.5 && Math.abs(plane.pitch) < 0.35) {
        plane.y = gh;
        plane.vy = 0;
        plane.onGround = true;
        if (!plane.landedAt && plane.speed < 5 && plane.x > mission.startRunway.endX) {
          plane.landedAt = { vy: plane.vy, runway: onEndRwy ? 'end' : 'start' };
        }
      } else if (plane.y < gh - 0.5 || (plane.y <= gh && !plane.onGround)) {
        triggerCrash();
        return;
      } else {
        plane.y = gh;
        plane.vy = 0;
        plane.onGround = true;
      }
    } else {
      plane.onGround = false;
    }

    // Ceiling
    if (plane.y > 800) { plane.y = 800; plane.vy = Math.min(plane.vy, 0); }

    // Fuel
    plane.fuel -= plane.throttle * FUEL_BURN * dt;
    if (plane.fuel <= 0) {
      plane.fuel = 0;
      plane.throttle = 0;
    }

    // Barrel roll detection
    const pitchDelta = plane.pitch - lastPitch;
    if (Math.abs(pitchDelta) > 0.02 && !plane.onGround) {
      if (rollAccum === 0) rollStart = performance.now();
      rollAccum += pitchDelta;
    } else {
      rollAccum = 0;
    }
    if (Math.abs(rollAccum) >= Math.PI * 2) {
      if (performance.now() - rollStart < 3000) {
        barrelRolls++;
        floatingTexts.push({text:'+50 BARREL ROLL!', x:plane.x, y:plane.y+30, life:2});
      }
      rollAccum = 0;
    }
    lastPitch = plane.pitch;

    // Update bombs
    bombs.forEach(b => {
      b.vy -= GRAVITY * dt;
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      const bgh = groundHeightAt(b.x, mission.terrain);
      if (b.y <= bgh) {
        b.y = bgh;
        b.hit = true;
        explosions.push({x:b.x, y:b.y, life:1.0});
      }
    });
    bombs = bombs.filter(b => !b.hit);
  }

  function triggerCrash() {
    plane.crashed = true;
    state = ST.CRASHED;
    explosions.push({x:plane.x, y:plane.y, life:2.0});
    setTimeout(() => { if (state === ST.CRASHED) showDebrief(false); }, 2000);
  }

  function dropBomb() {
    if (plane.onGround || state !== ST.PLAYING) return;
    bombs.push({
      x: plane.x, y: plane.y - 5,
      vx: plane.vx, vy: plane.vy - 2,
      hit: false
    });
  }

  // ===== OBJECTIVES =====
  function checkObjectives(mission) {
    if (currentObj >= objectives.length) return;
    const obj = objectives[currentObj];
    let met = false;

    switch (obj.type) {
      case 'altitude':
        met = plane.y * 3.28 >= obj.value;
        break;
      case 'waypoint':
        const dx = plane.x - obj.x;
        const dy = plane.y - obj.y;
        met = Math.sqrt(dx*dx + dy*dy) < 60;
        break;
      case 'land':
        if (plane.onGround && plane.speed < 5) {
          if (obj.runway === 'end') met = isRunway(plane.x, mission.endRunway);
          else met = isRunway(plane.x, mission.startRunway);
        }
        break;
      case 'bomb':
        // Check explosions near target
        for (const exp of explosions) {
          const dx2 = exp.x - obj.x;
          const dy2 = exp.y - (obj.y || groundHeightAt(obj.x, mission.terrain));
          if (Math.sqrt(dx2*dx2 + dy2*dy2) < obj.radius) { met = true; break; }
        }
        break;
    }

    if (met) {
      currentObj++;
      objCompleted++;
      floatingTexts.push({text:'OBJECTIVE COMPLETE!', x:plane.x, y:plane.y+40, life:2});
      if (currentObj >= objectives.length) {
        setTimeout(() => showDebrief(true), 1500);
      }
    }
  }

  // ===== TUTORIAL =====
  function checkTutorial(mission) {
    if (!mission.tutorial) return;
    const triggers = [
      {id:'welcome', cond: () => gameTime < 2 && plane.throttle === 0,
       msg: 'PAVEL: Set throttle to 80%. Use the left slider or UP arrow.'},
      {id:'flaps', cond: () => plane.throttle >= 0.7 && plane.flaps === 0 && plane.onGround,
       msg: 'PAVEL: Good! Set flaps to takeoff. Tap FLAPS or press F.'},
      {id:'rotate', cond: () => plane.flaps === 1 && plane.speed * 1.94 > 60 && plane.onGround,
       msg: 'PAVEL: Speed looks good! Gently pull nose up. Hold PITCH UP or press RIGHT arrow.'},
      {id:'gearup', cond: () => !plane.onGround && plane.y < 40 && plane.gear,
       msg: 'PAVEL: Airborne! Retract landing gear. Tap GEAR or press G.'},
      {id:'flapretract', cond: () => !plane.gear && plane.flaps !== 0 && plane.y > 20,
       msg: 'PAVEL: Good. Now retract flaps for cruise. Tap FLAPS or press F.'},
      {id:'climb', cond: () => plane.flaps === 0 && !plane.gear && plane.y > 20 && plane.y < 130,
       msg: 'PAVEL: Excellent! Climb to 500 ft. Keep nose slightly up.'},
      {id:'waypoint', cond: () => currentObj === 1 && plane.y * 3.28 > 450,
       msg: 'PAVEL: Good altitude! Head towards the waypoint marker ahead.'},
      {id:'descent', cond: () => currentObj >= 3 && plane.x > 6000,
       msg: 'PAVEL: Prepare to land. Reduce throttle, deploy gear (G), set flaps to landing (F twice).'},
      {id:'landing', cond: () => currentObj >= 3 && plane.y < 80 && plane.x > 6500,
       msg: 'PAVEL: Line up with the runway. Keep speed above 60 kts. Gentle descent!'},
    ];

    for (const t of triggers) {
      if (!tutorialFired[t.id] && t.cond()) {
        tutorialFired[t.id] = true;
        tutorialMsg = t.msg;
        tutorialTimer = 6;
        break;
      }
    }
  }

  // ===== SCORING =====
  function calculateScore(mission, completed) {
    let score = 0;
    if (completed) score += 1000;
    score += objCompleted * 200;

    let fuelBonus = 0, timeBonus = 0, landBonus = 0;
    if (completed) {
      fuelBonus = Math.min(300, Math.floor((plane.fuel / mission.par.fuel) * 300));
      if (gameTime <= mission.par.time) timeBonus = 300;
      else timeBonus = Math.floor(300 * (mission.par.time / gameTime));

      if (plane.landedAt) {
        const vspd = Math.abs(plane.landedAt.vy);
        if (vspd < 1) landBonus = 200;
        else if (vspd < 2) landBonus = 150;
        else if (vspd < 3) landBonus = 100;
        else landBonus = 50;
      }
    }
    score += fuelBonus + timeBonus + landBonus;
    score += barrelRolls * 50;

    const maxScore = 1000 + mission.objectives.length * 200 + 300 + 300 + 200;
    const pct = score / maxScore;
    const stars = pct >= 0.9 ? 3 : pct >= 0.7 ? 2 : pct >= 0.4 ? 1 : 0;

    return {score, stars, fuelBonus, timeBonus, landBonus, rollBonus: barrelRolls*50, completed};
  }

  function showDebrief(completed) {
    const mission = MISSIONS[missionIdx];
    debriefData = calculateScore(mission, completed);
    state = ST.DEBRIEF;

    if (completed) {
      if (!progress.scores[mission.id] || progress.scores[mission.id].score < debriefData.score) {
        progress.scores[mission.id] = {score: debriefData.score, stars: debriefData.stars};
      }
      if (missionIdx + 2 > progress.unlocked) {
        progress.unlocked = Math.min(MISSIONS.length, missionIdx + 2);
      }
      saveProgress();
    }
  }

  // ===== INPUT =====
  const keys = {};
  const pointers = new Map();

  document.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyF') cycleFlaps();
    if (e.code === 'KeyG') toggleGear();
    if (e.code === 'KeyB') dropBomb();
    if (e.code === 'KeyP' || e.code === 'Escape') togglePause();
    if (e.code === 'Space' || e.code === 'Enter') handleConfirm();
    e.preventDefault();
  });
  document.addEventListener('keyup', e => { keys[e.code] = false; });

  canvas.addEventListener('pointerdown', e => {
    e.preventDefault();
    const zone = getZone(e.clientX, e.clientY);
    pointers.set(e.pointerId, {zone, x: e.clientX, y: e.clientY});
    handleTouchStart(zone, e);
  });
  canvas.addEventListener('pointermove', e => {
    e.preventDefault();
    const info = pointers.get(e.pointerId);
    if (info) handleTouchMove(info.zone, e, info);
  });
  canvas.addEventListener('pointerup', e => {
    const info = pointers.get(e.pointerId);
    if (info) handleTouchEnd(info.zone);
    pointers.delete(e.pointerId);
  });
  canvas.addEventListener('pointercancel', e => {
    const info = pointers.get(e.pointerId);
    if (info) handleTouchEnd(info.zone);
    pointers.delete(e.pointerId);
  });

  // Touch zones
  const TZONE = { NONE:0, THROTTLE:1, PITCH_UP:2, PITCH_DOWN:3, FLAPS:4, GEAR:5, BOMB:6, UI:7 };

  function getZone(cx, cy) {
    const w = W(), h = H();
    // Non-playing states: everything is UI
    if (state !== ST.PLAYING && state !== ST.PAUSED) return TZONE.UI;

    // Throttle: left 65px, full height
    if (cx < 65) return TZONE.THROTTLE;
    // Pitch buttons: bottom-right
    const btnH = 70, btnW = 70, pad = 10;
    const pitchUpX = w - pad - btnW;
    const pitchDownX = w - pad - btnW * 2 - 8;
    const btnY = h - pad - btnH;
    if (cy > btnY && cx > pitchDownX) {
      if (cx > pitchUpX) return TZONE.PITCH_UP;
      return TZONE.PITCH_DOWN;
    }
    // Flaps/Gear/Bomb: bottom-left (after throttle)
    const fbY = h - pad - 55;
    if (cy > fbY && cx > 65) {
      if (cx < 65 + 60) return TZONE.FLAPS;
      if (cx < 65 + 125) return TZONE.GEAR;
      if (cx < 65 + 190) return TZONE.BOMB;
    }
    // Pause: top-right corner
    if (cx > w - 50 && cy < 40) return TZONE.UI;
    return TZONE.NONE;
  }

  let touchPitchUp = false, touchPitchDown = false;

  function handleTouchStart(zone, e) {
    if (zone === TZONE.PITCH_UP) touchPitchUp = true;
    if (zone === TZONE.PITCH_DOWN) touchPitchDown = true;
    if (zone === TZONE.FLAPS) cycleFlaps();
    if (zone === TZONE.GEAR) toggleGear();
    if (zone === TZONE.BOMB) dropBomb();
    if (zone === TZONE.THROTTLE) updateThrottle(e.clientY);
    if (zone === TZONE.UI) handleUITap(e.clientX, e.clientY);
  }

  function handleTouchMove(zone, e, info) {
    if (zone === TZONE.THROTTLE) updateThrottle(e.clientY);
  }

  function handleTouchEnd(zone) {
    if (zone === TZONE.PITCH_UP) touchPitchUp = false;
    if (zone === TZONE.PITCH_DOWN) touchPitchDown = false;
  }

  function updateThrottle(clientY) {
    if (state !== ST.PLAYING) return;
    const margin = 40;
    const range = H() - margin * 2;
    const t = 1 - Math.max(0, Math.min(1, (clientY - margin) / range));
    plane.throttle = Math.round(t * 20) / 20; // snap to 5% increments
  }

  function cycleFlaps() {
    if (state !== ST.PLAYING) return;
    plane.flaps = (plane.flaps + 1) % 3;
  }

  function toggleGear() {
    if (state !== ST.PLAYING) return;
    plane.gear = !plane.gear;
  }

  function togglePause() {
    if (state === ST.PLAYING) state = ST.PAUSED;
    else if (state === ST.PAUSED) state = ST.PLAYING;
  }

  function handleConfirm() {
    if (state === ST.MENU) return;
    if (state === ST.BRIEFING) startPlaying();
    if (state === ST.DEBRIEF) state = ST.MENU;
  }

  function handleUITap(cx, cy) {
    const w = W(), h = H();
    if (state === ST.MENU) {
      // Back button
      if (cx < 110 && cy < 45) {
        window.location.href = '../';
        return;
      }
      // Mission select
      const listX = w / 2 - 140, listW = 280;
      for (let i = 0; i < MISSIONS.length; i++) {
        const ly = 130 + i * 52;
        if (cx > listX && cx < listX + listW && cy > ly && cy < ly + 46) {
          if (i < progress.unlocked) {
            missionIdx = i;
            state = ST.BRIEFING;
          }
          return;
        }
      }
    }
    if (state === ST.BRIEFING) startPlaying();
    if (state === ST.DEBRIEF) state = ST.MENU;
    if (state === ST.PAUSED) {
      // Resume or quit
      if (cy > h/2 - 10 && cy < h/2 + 30) state = ST.PLAYING;
      if (cy > h/2 + 30 && cy < h/2 + 70) state = ST.MENU;
      // Top-right pause
      if (cx > w - 50 && cy < 40) state = ST.PLAYING;
    }
    if (state === ST.PLAYING) {
      // Pause button top-right
      if (cx > w - 50 && cy < 40) togglePause();
    }
  }

  function processKeyInput() {
    if (state !== ST.PLAYING) return;
    if (keys['ArrowUp']) plane.throttle = Math.min(1, plane.throttle + 0.02);
    if (keys['ArrowDown']) plane.throttle = Math.max(0, plane.throttle - 0.02);
    plane.pitchInput = 0;
    if (keys['ArrowRight'] || touchPitchUp) plane.pitchInput = 1;
    if (keys['ArrowLeft'] || touchPitchDown) plane.pitchInput = -1;
    if (!keys['ArrowRight'] && !keys['ArrowLeft'] && !touchPitchUp && !touchPitchDown) {
      plane.pitchInput = 0;
    }
  }

  // ===== MISSION START =====
  function startPlaying() {
    const mission = MISSIONS[missionIdx];
    resetPlane(mission);
    cam.x = plane.x;
    cam.y = 100;
    bombs = [];
    explosions = [];
    barrelRolls = 0;
    rollAccum = 0;
    objectives = mission.objectives.map(o => ({...o}));
    currentObj = 0;
    objCompleted = 0;
    gameTime = 0;
    tutorialMsg = '';
    tutorialTimer = 0;
    tutorialFired = {};
    floatingTexts = [];
    gustForce = 0;
    gustTimer = 0;
    lightningTimer = 0;
    turbulenceTimer = 0;
    rainDrops = [];
    if (mission.weather === 'storm') {
      for (let i = 0; i < 150; i++) {
        rainDrops.push({x: Math.random() * 2000, y: Math.random() * 800});
      }
    }
    state = ST.PLAYING;
    lastTime = performance.now();
  }

  // ===== DRAWING =====

  function drawSky(mission) {
    const g = ctx.createLinearGradient(0, 0, 0, H());
    if (mission.weather === 'night') {
      const nightProg = Math.min(1, plane.x / (mission.worldLength * 0.5));
      const r = Math.floor(30 - nightProg * 25);
      const gr2 = Math.floor(58 - nightProg * 48);
      const b = Math.floor(95 - nightProg * 55);
      g.addColorStop(0, `rgb(${r},${gr2},${b})`);
      g.addColorStop(1, `rgb(${r+60},${gr2+60},${b+40})`);
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W(), H());
      // Stars at night
      if (nightProg > 0.3) {
        ctx.fillStyle = `rgba(255,255,255,${nightProg * 0.8})`;
        for (let i = 0; i < 60; i++) {
          const sx = (i * 137.5 + cam.x * 0.02) % W();
          const sy = (i * 97.3) % (H() * 0.5);
          ctx.fillRect(sx, sy, 1.5, 1.5);
        }
      }
    } else if (mission.weather === 'storm') {
      g.addColorStop(0, '#2c3e50');
      g.addColorStop(1, '#5a6e7f');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W(), H());
    } else {
      g.addColorStop(0, '#1e3a5f');
      g.addColorStop(1, '#87CEEB');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W(), H());
    }
  }

  function drawClouds(mission) {
    if (mission.weather === 'storm') return; // storm draws own fog
    ctx.fillStyle = mission.weather === 'night' ? 'rgba(200,200,220,0.15)' : 'rgba(255,255,255,0.5)';
    for (let i = 0; i < 8; i++) {
      const cx = ((i * 600 + 100) - cam.x * 0.15) % (W() + 300) + (-100);
      const cy = 30 + (i * 47) % 120;
      const s = 25 + (i * 13) % 30;
      ctx.beginPath();
      ctx.arc(cx, cy, s, 0, Math.PI * 2);
      ctx.arc(cx + s * 0.7, cy - 5, s * 0.7, 0, Math.PI * 2);
      ctx.arc(cx + s * 1.2, cy, s * 0.6, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawFarMountains(mission) {
    if (!mission.farMountains || mission.farMountains.length === 0) return;
    const isNight = mission.weather === 'night';
    ctx.fillStyle = isNight ? '#1a2a3a' : '#2c3e50';
    ctx.beginPath();
    ctx.moveTo(0, H());
    for (const m of mission.farMountains) {
      const sx = (m.x - cam.x * 0.1) * PPM * 0.3 + W() * 0.1;
      const sy = H() * 0.65 - m.h * 0.4;
      ctx.lineTo(sx, sy);
    }
    ctx.lineTo(W(), H());
    ctx.fill();
  }

  function drawMidHills(mission) {
    const isNight = mission.weather === 'night';
    ctx.fillStyle = isNight ? '#1a3a1a' : '#3a5f3a';
    ctx.beginPath();
    ctx.moveTo(0, H());
    for (let x = -200; x < W() + 200; x += 80) {
      const wx = cam.x + (x - W()/2) / PPM / 0.3;
      const hy = 30 + Math.sin(wx * 0.003) * 25 + Math.cos(wx * 0.007) * 15;
      const sy = H() * 0.65 + 20 - hy * 0.5;
      ctx.lineTo(x, sy);
    }
    ctx.lineTo(W(), H());
    ctx.fill();
  }

  function drawTerrain(mission) {
    const isNight = mission.weather === 'night';
    const grad = ctx.createLinearGradient(0, H() * 0.6, 0, H());
    if (isNight) {
      grad.addColorStop(0, '#1a3a1a');
      grad.addColorStop(1, '#0d1a0d');
    } else {
      grad.addColorStop(0, '#4a7c3f');
      grad.addColorStop(1, '#3d2b1f');
    }
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(0, H());
    for (const pt of mission.terrain) {
      const s = w2s(pt.x, pt.y);
      ctx.lineTo(s.sx, s.sy);
    }
    ctx.lineTo(W(), H());
    ctx.fill();

    // Terrain edge
    ctx.strokeStyle = isNight ? '#0d2a0d' : '#2d5a27';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < mission.terrain.length; i++) {
      const s = w2s(mission.terrain[i].x, mission.terrain[i].y);
      if (i === 0) ctx.moveTo(s.sx, s.sy);
      else ctx.lineTo(s.sx, s.sy);
    }
    ctx.stroke();
  }

  function drawRunway(runway, mission) {
    const l = w2s(runway.x, runway.y);
    const r = w2s(runway.endX, runway.y);
    const rw = 14;
    const isNight = mission.weather === 'night';

    ctx.fillStyle = isNight ? '#333' : '#444';
    ctx.fillRect(l.sx, l.sy - rw / 2, r.sx - l.sx, rw);
    // Center line
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.setLineDash([12, 8]);
    ctx.beginPath();
    ctx.moveTo(l.sx, l.sy);
    ctx.lineTo(r.sx, r.sy);
    ctx.stroke();
    ctx.setLineDash([]);
    // Edge lines
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(l.sx, l.sy - rw / 2);
    ctx.lineTo(r.sx, r.sy - rw / 2);
    ctx.moveTo(l.sx, l.sy + rw / 2);
    ctx.lineTo(r.sx, r.sy + rw / 2);
    ctx.stroke();

    // Night runway lights
    if (isNight) {
      ctx.fillStyle = '#ffcc00';
      for (let x = runway.x; x <= runway.endX; x += 30) {
        const s = w2s(x, runway.y);
        ctx.beginPath();
        ctx.arc(s.sx, s.sy - rw / 2 - 2, 2, 0, Math.PI * 2);
        ctx.arc(s.sx, s.sy + rw / 2 + 2, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  function drawObjects(mission) {
    if (!mission.objects) return;
    for (const obj of mission.objects) {
      if (obj.type === 'target') {
        const gh = groundHeightAt(obj.x, mission.terrain);
        const s = w2s(obj.x, gh);
        // Red target circle
        ctx.strokeStyle = '#ff3333';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(s.sx, s.sy, obj.radius * PPM * 0.3, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.arc(s.sx, s.sy, obj.radius * PPM * 0.15, 0, Math.PI * 2); ctx.stroke();
        // Crosshair
        ctx.beginPath();
        ctx.moveTo(s.sx - 15, s.sy); ctx.lineTo(s.sx + 15, s.sy);
        ctx.moveTo(s.sx, s.sy - 15); ctx.lineTo(s.sx, s.sy + 15);
        ctx.stroke();
      } else if (obj.type === 'city') {
        for (let bx = obj.x; bx < obj.x + obj.width; bx += 25 + Math.random() * 15) {
          const bh = 15 + ((bx * 7) % 40);
          const gh = groundHeightAt(bx, mission.terrain);
          const s = w2s(bx, gh);
          const bw2 = 18;
          ctx.fillStyle = mission.weather === 'night' ? '#1a1a2e' : '#555';
          ctx.fillRect(s.sx - bw2 / 2, s.sy - bh, bw2, bh);
          // Windows
          ctx.fillStyle = mission.weather === 'night' ? 'rgba(255,255,200,0.6)' : 'rgba(255,255,200,0.3)';
          for (let wy = s.sy - bh + 5; wy < s.sy - 3; wy += 10) {
            for (let wx = s.sx - bw2/2 + 3; wx < s.sx + bw2/2 - 3; wx += 7) {
              ctx.fillRect(wx, wy, 3, 4);
            }
          }
        }
      } else if (obj.type === 'water') {
        const l = w2s(obj.x, 0);
        const r = w2s(obj.endX, 0);
        ctx.fillStyle = mission.weather === 'night' ? 'rgba(20,40,80,0.7)' : 'rgba(50,120,200,0.5)';
        ctx.fillRect(l.sx, l.sy - 5, r.sx - l.sx, H() - l.sy + 5);
      }
    }
  }

  function drawWaypoint(obj) {
    const s = w2s(obj.x, obj.y);
    // Diamond
    ctx.fillStyle = 'rgba(255,200,0,0.7)';
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s.sx, s.sy - 15);
    ctx.lineTo(s.sx + 10, s.sy);
    ctx.lineTo(s.sx, s.sy + 15);
    ctx.lineTo(s.sx - 10, s.sy);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Pulsing ring
    const pulse = 1 + Math.sin(frameCount * 0.1) * 0.3;
    ctx.strokeStyle = 'rgba(255,200,0,0.4)';
    ctx.beginPath();
    ctx.arc(s.sx, s.sy, 20 * pulse, 0, Math.PI * 2);
    ctx.stroke();
  }

  function drawTU95() {
    const s = w2s(plane.x, plane.y);
    ctx.save();
    ctx.translate(s.sx, s.sy);
    ctx.rotate(-plane.pitch);

    // Fuselage
    ctx.fillStyle = '#708090';
    ctx.beginPath();
    ctx.ellipse(0, 0, 36, 7, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 0.8;
    ctx.stroke();

    // Nose
    ctx.fillStyle = '#a0a0a0';
    ctx.beginPath();
    ctx.moveTo(34, -2.5);
    ctx.lineTo(46, 0);
    ctx.lineTo(34, 2.5);
    ctx.closePath();
    ctx.fill();

    // Wings (swept)
    ctx.fillStyle = '#607080';
    ctx.beginPath();
    ctx.moveTo(5, -5);
    ctx.lineTo(-12, -32);
    ctx.lineTo(-17, -30);
    ctx.lineTo(0, -5);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(5, 5);
    ctx.lineTo(-12, 32);
    ctx.lineTo(-17, 30);
    ctx.lineTo(0, 5);
    ctx.closePath();
    ctx.fill();

    // Engines (4 turboprops)
    const engines = [[-7, -16], [-3, -11], [-7, 16], [-3, 11]];
    engines.forEach(([ex, ey]) => {
      ctx.fillStyle = '#444';
      ctx.beginPath();
      ctx.arc(ex, ey, 2.5, 0, Math.PI * 2);
      ctx.fill();
      if (plane.throttle > 0) {
        ctx.strokeStyle = 'rgba(200,200,200,0.5)';
        ctx.lineWidth = 0.8;
        const a = (performance.now() * plane.throttle * 0.02) % (Math.PI * 2);
        ctx.beginPath();
        ctx.moveTo(ex + Math.cos(a) * 5, ey + Math.sin(a) * 5);
        ctx.lineTo(ex - Math.cos(a) * 5, ey - Math.sin(a) * 5);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ex + Math.cos(a + 1.05) * 5, ey + Math.sin(a + 1.05) * 5);
        ctx.lineTo(ex - Math.cos(a + 1.05) * 5, ey - Math.sin(a + 1.05) * 5);
        ctx.stroke();
      }
    });

    // Tail
    ctx.fillStyle = '#b22222';
    ctx.beginPath();
    ctx.moveTo(-32, 0);
    ctx.lineTo(-38, -13);
    ctx.lineTo(-34, -13);
    ctx.lineTo(-30, 0);
    ctx.closePath();
    ctx.fill();
    // Horizontal stabilizer
    ctx.fillStyle = '#607080';
    ctx.beginPath();
    ctx.moveTo(-37, -12);
    ctx.lineTo(-44, -17);
    ctx.lineTo(-44, -11);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-37, -12);
    ctx.lineTo(-44, -7);
    ctx.lineTo(-44, -13);
    ctx.closePath();
    ctx.fill();

    // Cockpit
    ctx.fillStyle = '#87CEEB';
    ctx.beginPath();
    ctx.ellipse(26, -1.5, 5, 3, -0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#6BA3C7';
    ctx.lineWidth = 0.6;
    ctx.stroke();

    // Landing gear
    if (plane.gear) {
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(18, 6); ctx.lineTo(18, 14); ctx.stroke();
      ctx.fillStyle = '#222';
      ctx.beginPath(); ctx.arc(18, 15, 2.5, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-8, 6); ctx.lineTo(-8, 14); ctx.stroke();
      ctx.beginPath(); ctx.arc(-8, 15, 2.5, 0, Math.PI * 2); ctx.fill();
    }

    // Red star
    drawStar(-12, -1.5, 3.5);

    ctx.restore();
  }

  function drawStar(sx, sy, r) {
    ctx.fillStyle = '#b22222';
    ctx.beginPath();
    for (let i = 0; i < 5; i++) {
      const a = -Math.PI / 2 + (i * 2 * Math.PI) / 5;
      const na = a + Math.PI / 5;
      ctx.lineTo(sx + Math.cos(a) * r, sy + Math.sin(a) * r);
      ctx.lineTo(sx + Math.cos(na) * r * 0.4, sy + Math.sin(na) * r * 0.4);
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawBombs(mission) {
    ctx.fillStyle = '#333';
    bombs.forEach(b => {
      const s = w2s(b.x, b.y);
      ctx.beginPath();
      ctx.arc(s.sx, s.sy, 4, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawExplosions() {
    explosions.forEach(exp => {
      const s = w2s(exp.x, exp.y);
      const r = (1 - exp.life) * 40 + 10;
      const alpha = exp.life;
      ctx.fillStyle = `rgba(255,150,0,${alpha * 0.8})`;
      ctx.beginPath(); ctx.arc(s.sx, s.sy, r, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = `rgba(255,255,100,${alpha * 0.5})`;
      ctx.beginPath(); ctx.arc(s.sx, s.sy, r * 0.5, 0, Math.PI * 2); ctx.fill();
    });
  }

  function drawWeather(mission, dt) {
    if (mission.weather === 'storm') {
      // Fog
      ctx.fillStyle = 'rgba(140,150,160,0.25)';
      ctx.fillRect(0, 0, W(), H());
      // Rain
      ctx.strokeStyle = 'rgba(180,200,220,0.5)';
      ctx.lineWidth = 1;
      rainDrops.forEach(r => {
        ctx.beginPath();
        const sx = (r.x - cam.x * 0.5 + frameCount * 3) % (W() + 200) - 100;
        const sy = (r.y + frameCount * 5) % (H() + 100) - 50;
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx - 3, sy + 12);
        ctx.stroke();
      });
      // Lightning
      lightningTimer -= dt;
      if (lightningTimer <= 0) {
        lightningTimer = 10 + Math.random() * 20;
        lightningFlash = true;
        setTimeout(() => { lightningFlash = false; }, 100);
      }
      if (lightningFlash) {
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(0, 0, W(), H());
      }
    }

    // Wind gusts
    if (mission.weather === 'windy' || mission.weather === 'storm') {
      gustTimer -= dt;
      if (gustTimer <= 0) {
        gustTimer = 2 + Math.random() * 3;
        gustForce = (Math.random() - 0.5) * (mission.weather === 'storm' ? 8 : 4);
      }
      gustForce *= 0.98; // decay
    }
  }

  function drawFloatingTexts(dt) {
    floatingTexts.forEach(ft => {
      ft.life -= dt;
      const s = w2s(ft.x, ft.y + (2 - ft.life) * 20);
      ctx.fillStyle = `rgba(255,255,0,${Math.max(0, ft.life / 2)})`;
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(ft.text, s.sx, s.sy);
    });
    floatingTexts = floatingTexts.filter(ft => ft.life > 0);
  }

  // ===== HUD =====
  function drawHUD(mission) {
    const w = W(), h = H();
    const fontSize = Math.max(11, Math.min(13, w * 0.018));
    const monoFont = `bold ${fontSize}px 'Courier New', monospace`;

    // Instrument panel background
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.beginPath();
    ctx.roundRect(70, 5, 175, 82, 6);
    ctx.fill();

    ctx.font = monoFont;
    ctx.textAlign = 'left';
    ctx.fillStyle = '#fff';
    const alt = Math.floor(plane.y * 3.28);
    const spd = Math.floor(plane.speed * 1.94);
    ctx.fillText(`ALT: ${alt} ft`, 78, 22);
    ctx.fillText(`SPD: ${spd} kts`, 78, 38);
    ctx.fillText(`FLAPS: ${FLAP_NAMES[plane.flaps]}`, 78, 54);

    // Gear indicator
    ctx.fillText('GEAR:', 78, 70);
    ctx.fillStyle = plane.gear ? '#4CAF50' : '#666';
    ctx.beginPath();
    ctx.arc(138, 66, 5, 0, Math.PI * 2);
    ctx.fill();

    // Fuel bar
    const fuelW = 60;
    const fuelX = 160, fuelY = 54;
    ctx.fillStyle = '#333';
    ctx.fillRect(fuelX, fuelY - 8, fuelW, 10);
    const fuelColor = plane.fuel > 50 ? '#4CAF50' : plane.fuel > 25 ? '#FFC107' : '#f44336';
    const flashFuel = plane.fuel < 10 && Math.sin(frameCount * 0.2) > 0;
    ctx.fillStyle = flashFuel ? '#ff0000' : fuelColor;
    ctx.fillRect(fuelX, fuelY - 8, fuelW * plane.fuel / 100, 10);
    ctx.fillStyle = '#fff';
    ctx.fillText(`${Math.floor(plane.fuel)}%`, fuelX + 2, fuelY + 14);

    // Throttle (text in HUD)
    ctx.fillStyle = '#fff';
    ctx.fillText(`THR: ${Math.floor(plane.throttle * 100)}%`, 160, 22);

    // Mission info top-right
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    const miW = Math.min(220, w * 0.35);
    ctx.beginPath();
    ctx.roundRect(w - miW - 10, 5, miW, 50, 6);
    ctx.fill();
    ctx.fillStyle = '#ffcc00';
    ctx.font = `bold ${Math.max(10, fontSize - 1)}px Arial`;
    ctx.textAlign = 'right';
    ctx.fillText(`M${mission.id}: ${mission.name.toUpperCase()}`, w - 18, 22);
    ctx.fillStyle = '#ccc';
    ctx.font = `${Math.max(10, fontSize - 1)}px Arial`;
    if (currentObj < objectives.length) {
      ctx.fillText(objectives[currentObj].text, w - 18, 42);
    } else {
      ctx.fillText('All objectives complete!', w - 18, 42);
    }

    // Throttle slider (left edge)
    drawThrottleSlider();

    // Touch control buttons
    drawTouchButtons(mission);

    // Warnings
    drawWarnings();

    // Tutorial
    if (tutorialTimer > 0 && tutorialMsg) {
      drawTutorialBubble();
    }

    // Waypoint arrow
    if (currentObj < objectives.length) {
      const obj = objectives[currentObj];
      if (obj.type === 'waypoint' || obj.type === 'bomb') {
        drawWaypoint(obj);
        // Distance indicator
        const dx = obj.x - plane.x;
        const dist = Math.abs(dx);
        if (dist > 100) {
          ctx.fillStyle = 'rgba(255,200,0,0.8)';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`${Math.floor(dist)}m`, w / 2, h - 100);
          // Arrow
          const arrowX = dx > 0 ? w / 2 + 40 : w / 2 - 40;
          ctx.beginPath();
          ctx.moveTo(arrowX, h - 105);
          ctx.lineTo(arrowX + (dx > 0 ? 10 : -10), h - 100);
          ctx.lineTo(arrowX, h - 95);
          ctx.fill();
        }
      }
    }

    // Pause button
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = 'bold 18px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('||', w - 25, 30);
  }

  function drawThrottleSlider() {
    const x = 8, y = 40, w2 = 48, h2 = H() - 80;
    // Track bg
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.roundRect(x, y, w2, h2, 8);
    ctx.fill();
    // Filled portion
    const fillH = h2 * plane.throttle;
    const grad = ctx.createLinearGradient(0, y + h2 - fillH, 0, y + h2);
    grad.addColorStop(0, '#4CAF50');
    grad.addColorStop(0.7, '#FFC107');
    grad.addColorStop(1, '#f44336');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.roundRect(x + 3, y + h2 - fillH, w2 - 6, fillH, 5);
    ctx.fill();
    // Label
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('THR', x + w2 / 2, y - 5);
    ctx.fillText(`${Math.floor(plane.throttle * 100)}%`, x + w2 / 2, y + h2 + 14);
    // Tick marks
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= 4; i++) {
      const ty = y + h2 * (1 - i / 4);
      ctx.beginPath(); ctx.moveTo(x, ty); ctx.lineTo(x + w2, ty); ctx.stroke();
    }
  }

  function drawTouchButtons(mission) {
    const w = W(), h = H();
    const pad = 10;

    // Pitch buttons (bottom-right)
    const btnH = 70, btnW = 70;
    const puX = w - pad - btnW, puY = h - pad - btnH;
    const pdX = w - pad - btnW * 2 - 8, pdY = puY;

    // Pitch Up
    ctx.fillStyle = touchPitchUp ? 'rgba(77,201,246,0.5)' : 'rgba(255,255,255,0.15)';
    ctx.beginPath(); ctx.roundRect(puX, puY, btnW, btnH, 10); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('\u25B2', puX + btnW / 2, puY + btnH / 2 + 2);
    ctx.font = '9px Arial';
    ctx.fillText('NOSE UP', puX + btnW / 2, puY + btnH - 8);

    // Pitch Down
    ctx.fillStyle = touchPitchDown ? 'rgba(77,201,246,0.5)' : 'rgba(255,255,255,0.15)';
    ctx.beginPath(); ctx.roundRect(pdX, pdY, btnW, btnH, 10); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('\u25BC', pdX + btnW / 2, pdY + btnH / 2 + 2);
    ctx.font = '9px Arial';
    ctx.fillText('NOSE DN', pdX + btnW / 2, pdY + btnH - 8);

    // Bottom-left buttons: FLAPS, GEAR, BOMB
    const sbW = 55, sbH = 50;
    const sbY = h - pad - sbH;
    const buttons = [
      {label: `FLAPS\n${FLAP_NAMES[plane.flaps]}`, x: 68},
      {label: `GEAR\n${plane.gear ? 'DOWN' : 'UP'}`, x: 68 + sbW + 5},
    ];
    // Only show bomb button on bombing missions
    const hasBombObj = mission.objectives.some(o => o.type === 'bomb');
    if (hasBombObj) {
      buttons.push({label: 'BOMB', x: 68 + (sbW + 5) * 2});
    }

    buttons.forEach(btn => {
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.beginPath(); ctx.roundRect(btn.x, sbY, sbW, sbH, 8); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
      const lines = btn.label.split('\n');
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 11px Arial';
      ctx.textAlign = 'center';
      if (lines.length > 1) {
        ctx.fillText(lines[0], btn.x + sbW / 2, sbY + sbH / 2 - 4);
        ctx.fillStyle = '#ffcc00';
        ctx.fillText(lines[1], btn.x + sbW / 2, sbY + sbH / 2 + 10);
      } else {
        ctx.fillText(lines[0], btn.x + sbW / 2, sbY + sbH / 2 + 4);
      }
    });
  }

  function drawWarnings() {
    const spd = plane.speed * 1.94;
    const alt = plane.y * 3.28;
    const w = W(), h = H();

    // Stall warning
    if (spd < STALL_SPEED * 1.94 * 0.9 && !plane.onGround && plane.speed > 2) {
      if (Math.sin(frameCount * 0.15) > 0) {
        ctx.fillStyle = 'rgba(255,0,0,0.8)';
        ctx.font = `bold ${Math.min(28, w * 0.05)}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('STALL WARNING', w / 2, h * 0.4);
      }
    }

    // Low altitude warning
    const mission = MISSIONS[missionIdx];
    const gh = groundHeightAt(plane.x, mission.terrain);
    if (plane.y - gh < 20 && !plane.onGround && plane.vy < 0) {
      if (Math.sin(frameCount * 0.15) > 0) {
        ctx.fillStyle = 'rgba(255,100,0,0.8)';
        ctx.font = `bold ${Math.min(24, w * 0.04)}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('PULL UP', w / 2, h * 0.48);
      }
    }

    // Gear reminder near runway
    if (!plane.gear && !plane.onGround) {
      const nearEnd = Math.abs(plane.x - mission.endRunway.x) < 400 && plane.y < 100;
      const nearStart = Math.abs(plane.x - mission.startRunway.x) < 400 && plane.y < 100;
      if (nearEnd || nearStart) {
        if (Math.sin(frameCount * 0.1) > 0) {
          ctx.fillStyle = 'rgba(255,200,0,0.8)';
          ctx.font = `bold ${Math.min(20, w * 0.035)}px Arial`;
          ctx.textAlign = 'center';
          ctx.fillText('GEAR DOWN!', w / 2, h * 0.55);
        }
      }
    }
  }

  function drawTutorialBubble() {
    const w = W(), h = H();
    const maxW = Math.min(400, w * 0.7);
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';

    // Wrap text
    const words = tutorialMsg.split(' ');
    const lines = [];
    let line = '';
    for (const word of words) {
      const test = line + (line ? ' ' : '') + word;
      if (ctx.measureText(test).width > maxW - 24) {
        lines.push(line);
        line = word;
      } else {
        line = test;
      }
    }
    if (line) lines.push(line);

    const lineH = 18;
    const boxH = lines.length * lineH + 16;
    const boxW = maxW;
    const bx = (w - boxW) / 2;
    const by = 65;

    ctx.fillStyle = 'rgba(0,50,100,0.85)';
    ctx.beginPath();
    ctx.roundRect(bx, by, boxW, boxH, 8);
    ctx.fill();
    ctx.strokeStyle = '#4dc9f6';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.fillStyle = '#fff';
    lines.forEach((l, i) => {
      ctx.fillText(l, w / 2, by + 16 + i * lineH);
    });
  }

  // ===== SCREENS =====

  function drawMenuScreen() {
    const w = W(), h = H();

    // Background
    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0, '#1a1a2e');
    g.addColorStop(1, '#16213e');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);

    // Title
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#1e3a5f';
    ctx.lineWidth = 3;
    const ts = Math.min(40, w * 0.08);
    ctx.font = `bold ${ts}px Arial`;
    ctx.textAlign = 'center';
    ctx.strokeText('TU-95', w / 2, 55);
    ctx.fillText('TU-95', w / 2, 55);
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = `${Math.min(14, w * 0.03)}px Arial`;
    ctx.fillText('SELECT MISSION', w / 2, 80);

    // Back button
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath(); ctx.roundRect(10, 10, 100, 30, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('< ARCADE', 60, 30);

    // Mission list
    const listW = 280, listX = w / 2 - listW / 2;
    for (let i = 0; i < MISSIONS.length; i++) {
      const m = MISSIONS[i];
      const ly = 100 + i * 52;
      const unlocked = i < progress.unlocked;
      const scored = progress.scores[m.id];

      ctx.fillStyle = unlocked ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.03)';
      ctx.beginPath(); ctx.roundRect(listX, ly, listW, 46, 8); ctx.fill();

      if (unlocked) {
        ctx.strokeStyle = 'rgba(77,201,246,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      ctx.fillStyle = unlocked ? '#fff' : '#555';
      ctx.font = `bold ${Math.min(15, w * 0.03)}px Arial`;
      ctx.textAlign = 'left';
      ctx.fillText(`${m.id}. ${m.name}`, listX + 12, ly + 20);

      if (scored) {
        // Stars
        ctx.fillStyle = '#ffcc00';
        ctx.font = '14px Arial';
        for (let s = 0; s < 3; s++) {
          ctx.fillText(s < scored.stars ? '\u2605' : '\u2606', listX + listW - 55 + s * 16, ly + 20);
        }
        ctx.fillStyle = '#aaa';
        ctx.font = '11px Arial';
        ctx.fillText(`${scored.score}`, listX + 12, ly + 37);
      } else if (!unlocked) {
        ctx.fillStyle = '#555';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('LOCKED', listX + 12, ly + 37);
      } else {
        ctx.fillStyle = '#4dc9f6';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText('NEW', listX + 12, ly + 37);
      }
    }

    // Controls hint
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '11px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Tap a mission to begin | Keyboard: \u2191\u2193 throttle, \u2190\u2192 pitch, F flaps, G gear', w / 2, h - 15);
  }

  function drawBriefingScreen() {
    const w = W(), h = H();
    const mission = MISSIONS[missionIdx];

    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, w, h);

    const panelW = Math.min(420, w * 0.85);
    const panelX = (w - panelW) / 2;
    const panelY = h * 0.1;

    ctx.fillStyle = 'rgba(22,33,62,0.95)';
    ctx.beginPath(); ctx.roundRect(panelX, panelY, panelW, h * 0.75, 12); ctx.fill();
    ctx.strokeStyle = 'rgba(77,201,246,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Title
    ctx.fillStyle = '#ffcc00';
    ctx.font = `bold ${Math.min(22, w * 0.045)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(`MISSION ${mission.id}: ${mission.name.toUpperCase()}`, w / 2, panelY + 35);

    // Briefing text (wrapped)
    ctx.fillStyle = '#ddd';
    ctx.font = `${Math.min(14, w * 0.03)}px Arial`;
    const bWords = mission.briefing.split(' ');
    let bLines = [], bLine = '';
    for (const word of bWords) {
      const test = bLine + (bLine ? ' ' : '') + word;
      if (ctx.measureText(test).width > panelW - 40) { bLines.push(bLine); bLine = word; }
      else bLine = test;
    }
    if (bLine) bLines.push(bLine);
    bLines.forEach((l, i) => { ctx.fillText(l, w / 2, panelY + 65 + i * 20); });

    // Objectives
    const objY = panelY + 70 + bLines.length * 20 + 10;
    ctx.fillStyle = '#4dc9f6';
    ctx.font = `bold ${Math.min(14, w * 0.028)}px Arial`;
    ctx.fillText('OBJECTIVES:', w / 2, objY);
    ctx.fillStyle = '#bbb';
    ctx.font = `${Math.min(13, w * 0.026)}px Arial`;
    mission.objectives.forEach((obj, i) => {
      ctx.fillText(`${i + 1}. ${obj.text}`, w / 2, objY + 22 + i * 18);
    });

    // Weather
    const wxY = objY + 30 + mission.objectives.length * 18;
    ctx.fillStyle = '#888';
    ctx.font = `12px Arial`;
    ctx.fillText(`Weather: ${mission.weather.toUpperCase()}`, w / 2, wxY);

    // Start button
    const btnY = panelY + h * 0.75 - 50;
    ctx.fillStyle = 'rgba(77,201,246,0.3)';
    ctx.beginPath(); ctx.roundRect(w / 2 - 60, btnY, 120, 36, 8); ctx.fill();
    ctx.strokeStyle = '#4dc9f6';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px Arial';
    ctx.fillText('START', w / 2, btnY + 23);
  }

  function drawDebriefScreen() {
    const w = W(), h = H();

    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, w, h);

    const panelW = Math.min(350, w * 0.8);
    const panelX = (w - panelW) / 2;
    const panelY = h * 0.08;

    ctx.fillStyle = 'rgba(22,33,62,0.95)';
    ctx.beginPath(); ctx.roundRect(panelX, panelY, panelW, h * 0.8, 12); ctx.fill();

    const d = debriefData;
    // Title
    ctx.fillStyle = d.completed ? '#4CAF50' : '#f44336';
    ctx.font = `bold ${Math.min(24, w * 0.05)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(d.completed ? 'MISSION COMPLETE' : 'MISSION FAILED', w / 2, panelY + 35);

    // Stars
    if (d.completed) {
      ctx.font = '28px Arial';
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = i < d.stars ? '#ffcc00' : '#444';
        ctx.fillText(i < d.stars ? '\u2605' : '\u2606', w / 2 - 30 + i * 30, panelY + 65);
      }
    }

    // Score breakdown
    let sy = panelY + (d.completed ? 95 : 65);
    const lines = [
      ['Objectives', `${objCompleted} x 200 = ${objCompleted * 200}`],
    ];
    if (d.completed) {
      lines.unshift(['Mission Complete', '+1000']);
      lines.push(['Fuel Bonus', `+${d.fuelBonus}`]);
      lines.push(['Time Bonus', `+${d.timeBonus}`]);
      lines.push(['Landing', `+${d.landBonus}`]);
    }
    if (d.rollBonus > 0) lines.push(['Barrel Rolls', `+${d.rollBonus}`]);

    ctx.font = `${Math.min(13, w * 0.028)}px Arial`;
    lines.forEach(([label, val]) => {
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'left';
      ctx.fillText(label, panelX + 25, sy);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'right';
      ctx.fillText(val, panelX + panelW - 25, sy);
      sy += 22;
    });

    // Total
    sy += 8;
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(panelX + 25, sy - 12); ctx.lineTo(panelX + panelW - 25, sy - 12); ctx.stroke();
    ctx.fillStyle = '#ffcc00';
    ctx.font = `bold ${Math.min(18, w * 0.04)}px Arial`;
    ctx.textAlign = 'left';
    ctx.fillText('TOTAL', panelX + 25, sy);
    ctx.textAlign = 'right';
    ctx.fillText(`${d.score}`, panelX + panelW - 25, sy);

    // Continue button
    const btnY = panelY + h * 0.8 - 50;
    ctx.fillStyle = 'rgba(77,201,246,0.3)';
    ctx.beginPath(); ctx.roundRect(w / 2 - 60, btnY, 120, 36, 8); ctx.fill();
    ctx.strokeStyle = '#4dc9f6';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('CONTINUE', w / 2, btnY + 23);
  }

  function drawPauseOverlay() {
    const w = W(), h = H();
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.min(32, w * 0.06)}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', w / 2, h / 2 - 30);

    // Resume
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.beginPath(); ctx.roundRect(w / 2 - 60, h / 2, 120, 32, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px Arial';
    ctx.fillText('RESUME', w / 2, h / 2 + 22);

    // Quit
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.roundRect(w / 2 - 60, h / 2 + 42, 120, 32, 8); ctx.fill();
    ctx.fillStyle = '#aaa';
    ctx.fillText('QUIT', w / 2, h / 2 + 64);
  }

  // ===== GAME LOOP =====
  function update(dt) {
    frameCount++;
    const mission = MISSIONS[missionIdx];

    if (state === ST.PLAYING) {
      gameTime += dt;
      processKeyInput();
      updatePhysics(dt, mission);
      checkObjectives(mission);
      if (mission.tutorial) checkTutorial(mission);

      // Camera
      cam.x += (plane.x + plane.vx * 0.4 - cam.x) * 0.06;
      cam.y += (plane.y + 80 - cam.y) * 0.04;

      // Tutorial timer
      if (tutorialTimer > 0) tutorialTimer -= dt;

      // Explosions decay
      explosions.forEach(e => { e.life -= dt; });
      explosions = explosions.filter(e => e.life > 0);
    }

    if (state === ST.MENU) {
      frameCount++;
    }
  }

  function render() {
    const mission = MISSIONS[missionIdx];

    if (state === ST.MENU) {
      drawMenuScreen();
      return;
    }

    if (state === ST.BRIEFING) {
      drawBriefingScreen();
      return;
    }

    if (state === ST.DEBRIEF) {
      drawDebriefScreen();
      return;
    }

    // Playing / Paused / Crashed: draw the game world
    drawSky(mission);
    drawClouds(mission);
    drawFarMountains(mission);
    drawMidHills(mission);
    drawTerrain(mission);
    drawRunway(mission.startRunway, mission);
    drawRunway(mission.endRunway, mission);
    drawObjects(mission);
    drawBombs(mission);
    drawExplosions();

    // Draw current waypoint
    if (state !== ST.CRASHED && currentObj < objectives.length) {
      const obj = objectives[currentObj];
      if (obj.type === 'waypoint') drawWaypoint(obj);
    }

    if (!plane.crashed) drawTU95();

    const dt = 1 / 60;
    drawWeather(mission, dt);
    drawFloatingTexts(dt);
    drawHUD(mission);

    if (state === ST.PAUSED) drawPauseOverlay();
  }

  function loop(now) {
    const dt = lastTime ? Math.min((now - lastTime) / 1000, 0.05) : 1 / 60;
    lastTime = now;

    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  </script>
</body>
</html>
